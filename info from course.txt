I. Curs AmigosCode "Get started with SpringBoot":
https://amigoscode.com/courses/267273/lectures/29454614

II. Curs AmigosCode "Spring Security":
https://amigoscode.com/courses/728126/lectures/13124043

III. Curs Angular Udemy:
https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14466410?start=0#overview
jitarciuc_antonio@yahoo.com
Locomondo0822!

Info from course I. ----------------------------------------------------------------------------------------------------

---------------- Request Info ----------------

GET = afisezi informatii
POST = preiei informatii
PUT = update
DELETE = sterge informatii

---------------- FLOW ----------------

request -> controller -> service -> repository
    controller : mapping the url
    service : backend method
    repository: interfata pt metode de call in database

StudentConfig:
    -aici se umple tabelul cu valori
    -configuram basically baza de date

Student:
    -clasa model
    -dupa field-urile ei se mapeaza tabelul student din baza de date student

---------------- Anotatii ----------------

@RestController	- transforma clasa in controller, adica pe acolo trec requesturile 

service layer : business logic 

@Component : declaram un bean ca sa putem da autowired cand instantiam un obiect al acelei clase 
dar noi mergem mai departe si o facem sa fie specifica @Service 


---------------- Database ----------------

Configuratia pt conectarea la database:
	spring.datasource.url=jdbc:postgresql://localhost:5432/students
	spring.datasource.username=
	spring.datasource.password=
	spring.jpa.hibernate.ddl-auto=create-drop
	spring.jpa.show-sql=true
	spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
	spring.jpa.properties.hibernate.format_sql=true
	
	PostgreSQL path: C:\Program Files\PostgreSQL\13
		pass: 1233
		port: 5432
		
	Comenzi pt bash cand te joci cu postgreSQL:
	1. psql -U postgres : sa te loghezi pe userul postgres cu parola 1233
	2. \l : afiseaza toate bazele de date 
	3. \du: afiseaza toti userii 
	4. \c student: te conectezi la baza de date "student"
	5. \d student: afiseaza toate coloanele cu tipurile de date
	6. SELECT * FROM student; : afiseaza tot tabelul
	
---------------- Repository pt Student ----------------

public interface StudentRepository extends JpaRepository<Student, Long> : 
	-deci primul e template object: Student : este tipul de date (definit ca o clasa) cu care vrem repositoryul sa lucreze 
	-al doilea e IDul de stocare declarat ca field

@Query("select s from Student s where s.nume = ?1")
    -Student este clasa noastra model, care e anotata ca fiind Entity, asta inseamna ca ea e folosita pt crearea tabelului din database
    -prin urmare s e o instanta a clasei Student si putem accesa orice field din ea

---------------- @TRANSIENT ----------------

https://amigoscode.com/courses/267273/lectures/29454627
se foloseste pt campuri din clasa ta care nu vrei sa apara in baza de date pentru ca pot fi calculate automat si doar afisate

---------------- PUT - UPDATE ----------------

videoul cu <Exercise Solution> arata niste validari

---------------- Executabil JAR al proiectului ----------------

http://localhost:8080/api/v1/students

Maven->clean, then Maven->install
si Project Files apare target folder
in terminal:
    cd target
    java -jar accessing... .jar
    java -jar accessing... .jar --server.port=8081 (daca vrei sa rulezi pe alt port)

Jar-ul se poate dockeriza, se poate deploy to a server so have fun

---------------- Difference between <junit-vintage-engine> and <junit-jupiter-engine> ----------------

junit-vintage-engine :

    Used in Junit-4 Testing.
    Used to call core classes and annotations.
    'Assert' which provide assertion methods for performing test.
    'Assume' used to place assumptions.
    Use annotation like, @Ignore, @Before, etc...

junit-jupiter-engine :

    Used in Junit-5 Testing
    Provide some API which helpful to write test cases.
    'Assertions' provides utility methods of assertion condition for testing.
    'Assumptions' - utility method provide condition based on assumption.
    Change the bit of annotation name like, @Disable, @BeforeAll, @BeforeEach, etc...

Info from course II. ---------------------------------------------------------------------------------------------------

in clasa ApplicationSecurityConfig vom configura tot ce este legat de autentificare

Daca vrei sa whitelistezi url-uri INAINTE de a te autentifica:
    -se scriu ca antMatchers(...)
    -cum am facut intre simbolul serpisor

protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()    //vrem sa autorizam requesturi
                .antMatchers("/", "index", "/css/*", "/js/*")
                .permitAll()
                                ~~~~~~~~~~~~~~~ .antMatchers("/api/v1/students") ~~~~~~~~~~~~~~~
                                ~~~~~~~~~~~~~~~ .permitAll() ~~~~~~~~~~~~~~~
                .anyRequest()           //orice request venit
                .authenticated()        //trebuie OBLIGATORIU sa fie autentificat
                .and()                  //si
                .httpBasic();           //mecanismul prin care verificam clientul care se logheaza cu userul sau cv pe aici
    }

-------------------- USER CREATI MANUAL --------------------

asa se adauga userii pe care vreau sa ii creez eu manual, carora le dau roluri, username, parola etc
acel return new InMem returneaza o LISTA de UserDetails, adica o lista de useri

protected UserDetailsService userDetailsService() {
         UserDetails checuUser = User.builder()
                .username("checu")
                .password("1233")
                .roles("STUDENT")           //ROLE_STUDENT
                .build();

        return new InMemoryUserDetailsManager(
                checuUser
        );
    }

-TOTUSI nu e suficient atat, e nevoie de un PasswordEncoder
-Astfel vom folosi BCRYPT Encoder
    https://www.baeldung.com/spring-security-registration-password-encoding-bcrypt

-------------------- Guava Library --------------------

https://guava.dev/releases/28.1-jre/api/docs/index.html?overview-summary.html

-------------------- Roles and Permissions --------------------

Am creat 2 roluri STUDENT si ADMIN declarate intr-un enum si 4 permisiuni declarate in alt enum.

Cele 2 roluri primesc anumite permisiuni
    ADMIN - toate 4
    STUDENT - 3, fara course:write

-------------------- URL accesat de un user cu un anumit rol --------------------

Daca vrem sa spunem ce url poate accesa un user, e nevoie sa ii impunem ca are un anumit rol:
    .antMatchers("/api/**").hasRole(STUDENT.name())

Pe viitor ne intereseaza ca ADMINul sa poata accesa orice, iar STUDENTul sa poata accesa numai informatiile despre el
In contextul licentei, inseamna ca studentii sa poata vedea daca au intrat sau nu in camin.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ai ramas la Permission Based Authentication